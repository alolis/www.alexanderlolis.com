"use strict";(globalThis.webpackChunkblog=globalThis.webpackChunkblog||[]).push([[8320],{897:e=>{e.exports=JSON.parse('{"permalink":"/node-js-fork-is-slow-deal-with-it","source":"@site/blog/node-js-fork-is-slow-deal-with-it.md","title":"Node.js fork is slow; Deal with it","description":"Dealing with Node.js fork slowness","date":"2021-09-27T00:00:00.000Z","tags":[{"inline":true,"label":"development","permalink":"/tags/development"},{"inline":true,"label":"battlefield","permalink":"/tags/battlefield"},{"inline":true,"label":"nodejs","permalink":"/tags/nodejs"},{"inline":true,"label":"javascript","permalink":"/tags/javascript"},{"inline":true,"label":"no_silver_bullet","permalink":"/tags/no-silver-bullet"}],"readingTime":4.68,"hasTruncateMarker":true,"authors":[{"name":"Alexander Lolis","title":"Software Engineer","url":"https://github.com/alolis","imageURL":"https://avatars.githubusercontent.com/u/82233?v=4","key":"alolis","page":null}],"frontMatter":{"slug":"node-js-fork-is-slow-deal-with-it","title":"Node.js fork is slow; Deal with it","date":"2021-09-27T00:00:00.000Z","description":"Dealing with Node.js fork slowness","authors":"alolis","tags":["development","battlefield","nodejs","javascript","no_silver_bullet"]},"unlisted":false,"prevItem":{"title":"My 2021 reads","permalink":"/my-2021-reads"},"nextItem":{"title":"Riding the bull; the npm package, that is","permalink":"/riding-the-bull"}}')},4482:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var s=n(897),t=n(4848),r=n(8453);const a={slug:"node-js-fork-is-slow-deal-with-it",title:"Node.js fork is slow; Deal with it",date:new Date("2021-09-27T00:00:00.000Z"),description:"Dealing with Node.js fork slowness",authors:"alolis",tags:["development","battlefield","nodejs","javascript","no_silver_bullet"]},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Approach",id:"approach",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const o={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(o.p,{children:["Yes. I know. Forking a process in ",(0,t.jsx)(o.code,{children:"Node.js"})," is slow. Instead of crying about it, let's see how we can handle it!"]}),"\n",(0,t.jsx)(o.p,{children:"Let's assume that you have a service in which you:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"Accept a request"}),"\n",(0,t.jsxs)(o.li,{children:["Fork a process with ",(0,t.jsx)(o.a,{href:"https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options",children:(0,t.jsx)(o.code,{children:"child_process.fork"})})]}),"\n",(0,t.jsx)(o.li,{children:"Execute some code within that process"}),"\n",(0,t.jsx)(o.li,{children:"Exit from the child process"}),"\n",(0,t.jsx)(o.li,{children:"Complete the request"}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["Probably the first thing you tried was to receive the request, spin up a process, do whatever you need in the processor, and exit. You timed the whole thing and your jaw dropped that it took a million years for the request to complete, even if you are just doing a ",(0,t.jsx)(o.code,{children:"console.log('I love kittens')"})," inside your processor."]}),"\n",(0,t.jsx)(o.p,{children:"Don't bother. I will tell you right now that the bottleneck is the forking."}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsxs)(o.p,{children:['"',(0,t.jsx)(o.strong,{children:"OUTRAGEOUS!"})," I should have used ",(0,t.jsx)(o.em,{children:"[INSERT_OTHER_TECH_HERE]"})," which is super awesomely fast and all the cool kids are using it! Some random dude on medium.com says it is true!"]}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.em,{children:"-- your loud voice"})}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"Well, instead of re-writting the whole thing in a different language, I have an alternative for you; **use a pool of forked child processes.\n**"}),"\n",(0,t.jsx)(o.h2,{id:"approach",children:"Approach"}),"\n",(0,t.jsxs)(o.p,{children:["The idea is straightforward; Upon service initialization, fork a bunch of processes, and whenever a request comes in, get a resource (a child process) from the pool and use ",(0,t.jsx)(o.code,{children:"IPC"})," communication to send commands to it. After the processor completes, return it to the pool."]}),"\n",(0,t.jsxs)(o.p,{children:["The first thing for all this of course, is a pool. The good news is that there is no need to implement your own, you can just use this lovely ",(0,t.jsx)(o.code,{children:"npm"})," package, ",(0,t.jsx)(o.a,{href:"https://www.npmjs.com/package/generic-pool",children:"generic-pool"}),", or the native ",(0,t.jsx)(o.a,{href:"https://nodejs.org/api/cluster.html",children:"cluster"})," module depending on your use case."]}),"\n",(0,t.jsxs)(o.p,{children:["For this post, I will use ",(0,t.jsx)(o.code,{children:"generic-pool"})," so lets start with the processors pool which will look something like this:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-javascript",metastring:'title="pool.js"',children:"import {fork} from 'child_process';\nimport GenericPool from 'generic-pool';\nimport logger from '/your/logger';\n\nconst commandProcessorsPool = GenericPool.createPool({\n  create: () => {\n    const modulePath = path.join(__dirname, 'processor.js');\n    const commandProcessor = fork(modulePath);\n\n    logger.debug(`Forked command processor with pid ${commandProcessor.pid}`);\n\n    return commandProcessor;\n  },\n  destroy: (commandProcessor) => {\n    logger.debug(`Destroying command processor with pid ${commandProcessor.pid}`);\n\n    commandProcessor.removeAllListeners();\n    commandProcessor.kill('SIGKILL');\n  },\n  validate: commandProcessor => commandProcessor.connected && !commandProcessor.killed\n}, {\n  testOnBorrow: true,\n  min: 2, // Depending on your load, set a MINIMUM number of processes that should always be available in the pool\n  max: 5 // Depending on your load, set a MAXIMUM number of processes that should always be available in the pool\n});\n\ncommandProcessorsPool.on('factoryCreateError', logger.debug);\ncommandProcessorsPool.on('factoryDestroyError', logger.debug);\n"})}),"\n",(0,t.jsx)(o.p,{children:"And of course, you will also need to implement the actual processor which looks like this:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-javascript",metastring:'title="processor.js"',children:"import {serializeError} from 'serialize-error';\nimport logger from '/your/logger';\nimport {MESSAGE_STATUS} from './pool.js';\n\nprocess.on('message', async (message) => {\n  try {\n    // Read and validate input data from `message` and do whatever you need to do...\n    const {name} = message;\n    const result = await petKitten(name);\n    \n    // All went well, send the result of your function to the parent process...\n    process.send({status: MESSAGE_STATUS.OK, data: result});\n  } catch (e) {\n    logger.debug(e);\n\n    /* \n      In the real world, your processor will probably need to handle errors as well and pass those errors to\n      the parent process. Unfortunately, sending `Error` instances via `IPC` is not possible, BUT, we can just\n      serialize them and then deserialize them on the parent process!\n    */\n    process.send({status: MESSAGE_STATUS.ERROR, data: serializeError(e)});\n  }\n};\n"})}),"\n",(0,t.jsx)(o.p,{children:"Going back to our pool implementation, the only thing left now is the function that will be executing our commands:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-javascript",metastring:'title="pool.js"',children:"// ... omitted previous code for succinctness\n\nimport {deserializeError} from 'serialize-error';\n\nconst MESSAGE_STATUS = {\n  OK: 'ok',\n  ERROR: 'error',\n};\n  \nasync function executeCommand(params) {\n  const commandProcessor = await commandProcessorsPool.acquire();\n  \n  try {\n    const commandProcessorTask = () => {\n      return new Promise((resolve, reject) => {\n        // https://nodejs.org/api/child_process.html#child_process_event_error\n        commandProcessor.on('error', reject);\n\n        commandProcessor.on('message', (message) => {\n          const {status, data} = message;\n\n          const handlersMap = {\n            [MESSAGE_STATUS.OK]: () => resolve(data),\n            \n            // Don't forget to deserialize the error first!\n            [MESSAGE_STATUS.ERROR]: () => reject(deserializeProcessorError(data)           \n          };\n\n          const handler = handlersMap[status];\n\n          if (!handler) {\n            return reject(new Error(`Unknown command processor message status '${status}'`));\n          }\n\n          handler();\n        });\n\n        commandProcessor.send(params);\n      });\n    };\n    \n    const result = await commandProcessorTask();\n    \n    return result;\n  } finally {\n    // Make sure that the command processor is returned to the pool no matter what happened\n    await commandProcessorsPool.release(commandProcessor);\n  }\n}\n\nexport {\n  MESSAGE_STATUS,\n  executeCommand\n}\n"})}),"\n",(0,t.jsxs)(o.p,{children:["For the shake of this example, I am going to assume that you are using ",(0,t.jsx)(o.code,{children:"express.js"}),". The following is a very simple and short snippet on how to bring everything together, and execute a command when a request is received:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-javascript",metastring:'title="express.js"',children:"import express from 'express';\nimport {executeCommand} from './pool.js'; // By importing the file, our pool will be initialized\nimport logger '/your/logger';\n\nconst app = express();\n\napp.post('/pet_kitten', (req, res) => {\n  const {name} = req.body;\n  \n  // If this is a long-running process, then we shouldn't really block the request by using await.\n  // Depending on your case here, you might want to handle the actual command execution differently.\n  executeCommand({name}).catch(logger.error);\n\n  res.status(202); // HTTP Status Accepted\n  res.json({message: `Petting ${name} is underway...`});\n\napp.listen(3000, () => {\n  logger.info(`kitten app listening at http://localhost:${port}`)\n})\n"})}),"\n",(0,t.jsx)(o.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(o.p,{children:["Although the above was a simple real world example on how to use a pool of processes, it can be the basis for more advanced usage. For example each processor can be modified to accept various commands instead of being limited to just one function. You could also add an ",(0,t.jsx)(o.code,{children:"onMessage"})," event handler to support commands that send updates while they are being executed. I will leave those for another blog post!"]}),"\n",(0,t.jsx)(o.p,{children:"Depending on your use case though, you can do a lot of different things by expanding the approach I have just described."}),"\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.strong,{children:"The important thing here is to remember that most of the time, the problem is not the tool, it's your attitude towards the tool. Be creative and solve shit."})})]})}function h(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>i});var s=n(6540);const t={},r=s.createContext(t);function a(e){const o=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:o},e.children)}}}]);