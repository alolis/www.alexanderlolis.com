"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[558],{5680:(e,t,a)=>{a.d(t,{xA:()=>d,yg:()=>p});var n=a(6540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),h=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=h(a),m=i,p=c["".concat(l,".").concat(m)]||c[m]||u[m]||o;return a?n.createElement(p,r(r({ref:t},d),{},{components:a})):n.createElement(p,r({ref:t},d))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,r[1]=s;for(var h=2;h<o;h++)r[h]=a[h];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7566:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=a(8168),i=(a(6540),a(5680));const o={slug:"authorization-in-a-microservices-world",title:"Authorization in a microservices world",date:new Date("2022-03-20T00:00:00.000Z"),author:"Alexander Lolis",author_url:"https://github.com/alolis",author_image_url:"https://avatars.githubusercontent.com/u/82233?v=4",tags:["microservices","authorization","architecture","battlefield","development"]},r=void 0,s={permalink:"/authorization-in-a-microservices-world",source:"@site/blog/authorization-in-a-microservices-world.md",title:"Authorization in a microservices world",description:"Authorization? How hard can it be? I am pretty sure that others have already solved it. We are not the first ones doing microservices. It should be easy to integrate what's already out there.",date:"2022-03-20T00:00:00.000Z",formattedDate:"March 20, 2022",tags:[{label:"microservices",permalink:"/tags/microservices"},{label:"authorization",permalink:"/tags/authorization"},{label:"architecture",permalink:"/tags/architecture"},{label:"battlefield",permalink:"/tags/battlefield"},{label:"development",permalink:"/tags/development"}],readingTime:25.365,truncated:!0,prevItem:{title:"My 2022 reads",permalink:"/my-2022-reads"},nextItem:{title:"My 2021 reads",permalink:"/my-2021-reads"}},l=[{value:"The monolith",id:"the-monolith",children:[]},{value:"Authorization flow overview",id:"authorization-flow-overview",children:[]},{value:"Architectures",id:"architectures",children:[{value:"With an authorization service",id:"with-an-authorization-service",children:[]},{value:"With an authorization service and a data service",id:"with-an-authorization-service-and-a-data-service",children:[]},{value:"With an authorization middleware and library per service",id:"with-an-authorization-middleware-and-library-per-service",children:[]}]},{value:"Implementation",id:"implementation",children:[{value:"RBAC",id:"rbac",children:[]},{value:"RBAC/ABAC",id:"rbacabac",children:[]},{value:"Potential problems",id:"potential-problems",children:[]}]},{value:"Conclusion",id:"conclusion",children:[]}],h={toc:l},d="wrapper";function c(e){let{components:t,...o}=e;return(0,i.yg)(d,(0,n.A)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},"Authorization? How hard can it be? I am pretty sure that others have already solved it. We are not the first ones doing microservices. It should be easy to integrate what's already out there. "),(0,i.yg)("p",{parentName:"blockquote"},"-"," Everybody when they started designing their microservices, before they cried")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Fine-grained authorization in microservices is hard.")," Definitely not impossible, but hard. You would expect that a more standardized, all-around, full-proof solution is out there, but I am afraid there isn't. It's a complex matter and depending on what you are building, implementation varies."),(0,i.yg)("p",null,"You will probably start with a boolean ",(0,i.yg)("inlineCode",{parentName:"p"},"admin")," flag in your ",(0,i.yg)("inlineCode",{parentName:"p"},"User")," model and then you will replace it with a ",(0,i.yg)("inlineCode",{parentName:"p"},"role")," field, as we all did. However, as things progress and the business model becomes more and more complex, so do the solutions that we need to implement in order to deal with that complexity."),(0,i.yg)("p",null,"But how do you actually go ",(0,i.yg)("strong",{parentName:"p"},"from a simple flag")," to ",(0,i.yg)("strong",{parentName:"p"},"Role Based Access Control (RBAC)")," and then to ",(0,i.yg)("strong",{parentName:"p"},"Attribute Based Access Control (ABAC)"),", especially in a microservices environment? In the following post I hope to help you get there."),(0,i.yg)("p",null,(0,i.yg)("em",{parentName:"p"},"(UPDATE: 02/04/2022): This article made it to the HackerNews frontpage and some interesting comments can be found ",(0,i.yg)("a",{parentName:"em",href:"https://news.ycombinator.com/item?id=30878926"},"here"),". Feel free to participate!")),(0,i.yg)("h2",{id:"the-monolith"},"The monolith"),(0,i.yg)("p",null,"The first time I had to deal with a more complex authorization system was in a ",(0,i.yg)("strong",{parentName:"p"},"monolithic CMS application")," written in ",(0,i.yg)("inlineCode",{parentName:"p"},"PHP 5.x"),", on top of ",(0,i.yg)("strong",{parentName:"p"},"Zend Framework")," (now known as Laminas Project), with a ",(0,i.yg)("strong",{parentName:"p"},"MySQL")," backend, a billion years ago. The app was following the hot and trendy ",(0,i.yg)("strong",{parentName:"p"},"Model-View-Controller (MVC)")," pattern and the requirement in the specific project was, except hierarchical role-based access control (H-RBAC), to have more fine-grained permissions as well as to be able to answer two specific questions: "),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Can the user do X on a Y resource if their role allows it or if the resource is owned by them?")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Can the user A, with role X, access the data of user B, that has the same or a higher level role?"))),(0,i.yg)("p",null,"(For the sake of simplicity and because it does not really offer any extra value, I will skip the implementation details of question 2 and I will just use question 1 for my example below)."),(0,i.yg)("p",null,"After thinking about the situation, and the fact that we had a VERY specific problem to solve, that I KNEW it wouldn't change in the future, and ALL the data models were associated with a single user, this is what a very simplified version looked like (forgive my PHP, it's a bit rusty):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-php",metastring:"title=controllers/items_controller.php",title:"controllers/items_controller.php"},"class ItemsController extends Zend_Controller_Action {\n  // ...omitted code\n  \n  public function listAction() {\n    $page = $this->_getParam('page', 1);\n    $orderBy = $this->_getParam('order_by', 'created_at');\n    $order = $this->_getParam('order', 'desc');\n    \n    $filters = array('drafts' => false);\n    $user = Session::getUser();\n    \n    if ($user->isAuthorized('can_list_drafts', 'items')) {\n      $filters['drafts'] = $this->_getParam('drafts', false);\n    \n    $result = ItemModel::find($filters, $page, $orderBy, $order);\n  \n    return $result;\n  }\n  \n  public function destroyAction() \n  {\n    $itemId = $this->_request->getParam('itemId');\n    $item = ItemModel::findById($itemId);\n  \n    if (!$item) {\n      throw new ItemNotFoundException();\n    }\n    \n    $user = Session::getUser();\n    \n    if (!$user->hasRoleOrSelfPermissionOn('can_delete_items', 'can_delete_own_items', 'items', $item)\n      throw new AuthorizationException();\n    \n    $result = $item->destroy();\n    \n    return $result;\n  }\n  \n  // ... rest of code\n}\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-php",metastring:"title=models/user.php",title:"models/user.php"},"class User {    \n  // ...omitted code\n  \n  public isAuthorized($permission, $resource) \n  {\n    // The ACL singleton class is a wrapper around Zend ACL which is a module that provides you\n    // with hierarchical, role based, access control lists which you can query and check\n    // if a role has the requested permission on a resource.\n    if (ACL::getInstance()->isAuthorized($this->role, $permission, $resource)\n      return true;      \n\n    return false;\n  }\n  \n  public hasRoleOrSelfPermissionOn($rolePermission, $selfRolePermission, $resource, $model)\n  {\n    if ($this->isAuthorized($rolePermission, $resource) {\n      return true;\n    }\n    elseif ($model.userId == $this.id) {\n      if ($this->isAuthorized($selfRolePermission, $resource))\n        return true;\n    }\n    \n    return false;\n  }\n  \n  // ...rest of code\n}\n")),(0,i.yg)("p",null,"A few things are going on above:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"The decision point and enforcement of authorization is happening in the controller, getting mixed with application code that does not care about all these things"),", plus, it makes it harder to test. We do not want that. We want our controllers to be lean (in terms of responsibilities) and just return appropriate responses which are related to what was requested in the first place. "),(0,i.yg)("li",{parentName:"ol"},"In ",(0,i.yg)("inlineCode",{parentName:"li"},"listAction")," we need to check individual filters in order to decide if the user is authorized to use them or not. If multiple filters exist that need to be checked, the controller will become too messy, too fast."),(0,i.yg)("li",{parentName:"ol"},"The application data that the authorization requires (in this case ",(0,i.yg)("inlineCode",{parentName:"li"},"$item"),") are locally available and easily loaded with our ",(0,i.yg)("inlineCode",{parentName:"li"},"ItemModel")," class. As you will understand later, loading necessary application data is the biggest pain point."),(0,i.yg)("li",{parentName:"ol"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"User")," class is suddenly coupled with authorization. It shouldn't. It should only care about the user entity itself, like the class name implies."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("inlineCode",{parentName:"li"},"hasRoleOrSelfPermissionOn")," makes the assumption that all models have a ",(0,i.yg)("inlineCode",{parentName:"li"},"userId")," field which means that we should know beforehand that this will be true (forever) or else the function will not work as expected. ")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"The authorization code is tedious, poluting the controllers, and error prone"),". However, we were also lucky because this was the ugliest it could get (based on project requirements) and therefore it was acceptable (or at least we persuaded ourselves that it was), instead of pushing to a more complex solution. If, for example, there was the requirement of checking multiple model attributes (or attributes from different models), depending on the controller action, then ",(0,i.yg)("inlineCode",{parentName:"p"},"hasRoleOrSelfPermissionOn")," wouldn't be able to cover everything and the controllers would immediately become much messier. It did serve us well back then but I no longer like it because avoiding tangling code at some point became a priority."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"What I am describing above is not inherent to monoliths.")," The same implementation could have been done in a microservice (and I have seen it in multiple occasions, with everything done in the controllers) if the application data that the authorization mechanism required, lived under the same roof. But more on that later."),(0,i.yg)("h4",{id:"so-what-could-we-have-done-to-improve-the-above-situation"},"So, what could we have done to improve the above situation?"),(0,i.yg)("p",null,"Push the authorization code higher up in the stack. That would mean that you could push it to somewhere like a ",(0,i.yg)("inlineCode",{parentName:"p"},"middleware"),", as most web frameworks call it, which is basically code that is executed before your controllers. And this, is where the fun begins and a whole new set of implementation problems rises!"),(0,i.yg)("p",null,"But before we dive into that, we need to think about our authorization flow in a more abstract level."),(0,i.yg)("h2",{id:"authorization-flow-overview"},"Authorization flow overview"),(0,i.yg)("p",null,"So, what would this authorization mechanism look like in order to not force a single architecture but be more flexible instead? The following diagram will give you an idea:"),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Authorization Overview",src:a(2540).A}))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"The flow goes like this:")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"User requests to view record A."),(0,i.yg)("li",{parentName:"ol"},"The request is intercepted by the ",(0,i.yg)("strong",{parentName:"li"},"Policy Enforcement Point (PEP)"),". This is usually a ",(0,i.yg)("strong",{parentName:"li"},"middleware"),", or generally speaking, a layer in your stack, as high as possible, in order for the request to stop right there in case it's not authorized, instead of allowing it to travel deeper in the system."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"PEP")," makes a request to the ",(0,i.yg)("strong",{parentName:"li"},"Policy Decision Point (PDP)")," in order to figure out whether or not the request is authorized to move forward. PDP will probably be a library that keeps track of roles, permissions and resources and expose an interface in order to query it and get a boolean answer whether or not someone can do something on a resource."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"PDP")," ",(0,i.yg)("em",{parentName:"li"},"might")," need extra information in order to decide if the request should be allowed or denied so it needs to ask the ",(0,i.yg)("strong",{parentName:"li"},"Policy Information Point (PIP)")," for that extra information. That extra information can be retrieved from a database, from a flat file, from an external service or from any other source you need. PIP could be just another library which PDP can use internally if it needs to."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"PIP")," loads the extra information and returns it to the PDP."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"PDP"),", in combination with the extra information it got from PIP, evaluates the defined policy (which can be stored anywhere you like, e.g. database or flat file), and decides whether or not the request has access to the underlying resource based on what the policy says. "),(0,i.yg)("li",{parentName:"ol"},"The answer ",(0,i.yg)("strong",{parentName:"li"},"is returned to PEP"),", which either allows or denies the request to move forward.")),(0,i.yg)("p",null,"On the diagram above there is another piece, ",(0,i.yg)("strong",{parentName:"p"},"the Policy Administration Point (PAP)"),". This is basically an optional interface that helps you manage the policies. It can be anything, a web interface, a command line tool, a desktop GUI or you can just skip it entirely if you do not want to provide it and do everything manually instead."),(0,i.yg)("h2",{id:"architectures"},"Architectures"),(0,i.yg)("p",null,"Now that we have defined our authorization flow, let's go through a few real world architectures together. All the following architectures include a diagram and within this diagram I make clear what plays which role based on what I showed you earlier."),(0,i.yg)("h3",{id:"with-an-authorization-service"},"With an authorization service"),(0,i.yg)("p",null,"So, you are there thinking, I am doing microservices, right? So the logical thing to do is to implement an ",(0,i.yg)("strong",{parentName:"p"},"authorization service")," and everybody would be able to use that and keep your precious service boundaries, right? ",(0,i.yg)("strong",{parentName:"p"},"WRONG"),". Your hell, has just begun!"),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overview",src:a(8930).A}))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"How will PIP fetch the application data that PDP needs?")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Direct DB reads:")," I am pretty sure someone will suggest this, and then will say, ",(0,i.yg)("em",{parentName:"li"},"\"I know we shouldn't be doing this in microservices but let's just make this exception\""),", but that's how all big problems are created. With a small exception here, with another one there, and then things start to blow up, or even worst, become unmaintenable. Direct DB reads, outside the domain of each service, is a bad idea and it will be obvious to you why on the first schema change. Please don't be lazy and just say no to this."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Attach all the extra data to the authorization service call:."),' By doing this you will probably increase the network traffic and you might cause a bottleneck on the service if every request has a lot of data attached. However, these - manageable - disadvantages are not even my main concern with this approach. My main concern is the fact that the caller now needs to know the authorization logic that will be used internally by the authorization service in order to send the appropriate data. This will probably lead to callers sending more data than they should, or not removing data from the call whenever a policy changes, "just to be sure", and as a result the code maintenance will become harder. Even in a perfect world, were the data are ALWAYS exactly what is needed, the extra work of choosing the data is a burden that the caller should not have.'),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Keep a copy of the data the authorization service needs:")," This basically means syncing the data from all the other services, to the authorization service database, with a generic model that will be able to fit (in terms of a schema) everything. I can tell you right now that, this is difficult to achieve, especially if the syncing is experiencing network delays and/or conflicts. There are others who are doing this (check ",(0,i.yg)("a",{parentName:"li",href:"https://research.google/pubs/pub48190/"},"Google Zanzibar"),"), but for most mortal companies I think dealing with the complexities of syncing on your first implementation, is an overkill. Besides, even Zanzibar is not a silver bullet and it's higly opinionated with its models, so you might need to build extra parts that communicate with it in order to achieve what you want. ")),(0,i.yg)("h3",{id:"with-an-authorization-service-and-a-data-service"},"With an authorization service and a data service"),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overview",src:a(697).A}))),(0,i.yg)("p",null,"This is probably the most complex architecture but it definitely clears things up a bit. If the data state and the mutations are all handled by the same layer (a data service), and all other services use that layer, it's like they have direct access to the database and the PIP can now fetch whatever it needs."),(0,i.yg)("p",null,"Personally, I like this architecture because now there is a very clear seperation of who is doing what, even if it means that more code will be required in order to set it up. Building a data service is beyond the scope of this post so I will just keep it simple and say that you shouldn't start with this, unless you already have a data service implemented or if you have other needs for it that go beyond authorization."),(0,i.yg)("h4",{id:"variations"},"Variations"),(0,i.yg)("p",null,"There are a couple of variations with this architecture that I would like to mention since someone might find them interesting."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Instead of doing the authorization within each internal service, you could do the authorization at the API Gateway.")," You can use an authorization middleware within the API Gateway in order to communicate with the authorization service, or, you can even get rid of it completely and communicate with the data service directly from the middleware."),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overview",src:a(2755).A}))),(0,i.yg)("p",null,"This has the advantage of stopping the request as early as possible before it has the chance to reach the internal services. In general, I like that idea."),(0,i.yg)("p",null,"However, it also has a couple of disadvantages: "),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"When services make internal calls, they will be bypassing the authorization checks. It might be acceptable in your case but personally I do not like it. I want each service to allow only what is expected and nothing more. You could enforce in your implementation to make all the calls go through the API Gateway but then you increase the network latency and you lose all the advantages of actually having an internal network."),(0,i.yg)("li",{parentName:"ol"},"API Gateway will need to have all the application data loaders (for PIP) implemented there and things might get messy if you are implementing too much. Especially if you have a lot of services you might be changing API Gateway too often for reasons unrelated with the service itself.")),(0,i.yg)("h3",{id:"with-an-authorization-middleware-and-library-per-service"},"With an authorization middleware and library per service"),(0,i.yg)("div",{style:{textAlign:"center"}},(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overview",src:a(360).A}))),(0,i.yg)("p",null,"In my opinion ",(0,i.yg)("strong",{parentName:"p"},"this is probably a good balance between complexity and a scalable solution"),". You basically keep the authorization logic in each service and each service is responsible for the authorization rules of its own domain."),(0,i.yg)("p",null,"One thing you will probably need is to have the common code implemented as a library (or libraries) since it will be shared among all services but it shouldn't be a problem. Just make sure you cover it with enough tests!"),(0,i.yg)("p",null,"The real question with this approach is; ",(0,i.yg)("strong",{parentName:"p"},"how homogeneous is your system"),"? If it's 100% then you are in luck. You will only need to implement (or find) everything you need once. if it's not, you will need to do it for every different language you are using in your system. Even though there are plenty of libraries out there, depending on your system details, they might not integrate very well or they might be missing a couple of features that you might need. Before you are too eager to implement your own, make sure if an existing solution covers your needs. If it does not, maybe you can get away with it by doing a few changes on your side, or by adding those missing features to the library you found. Whatever you do, take the time to decide carefully."),(0,i.yg)("h2",{id:"implementation"},"Implementation"),(0,i.yg)("h3",{id:"rbac"},"RBAC"),(0,i.yg)("p",null,"If you are doing RBAC, then implementing this is straight forward and clean. You just need a middleware (PEP) in which you must check if the user role (usually attached to a JWT that comes with the request) has access to the specified route path. The policies can easily be stored in a database or a configuration file, load them upon service initialization and let the RBAC library (PDP) that you will use do its work from within your middleware. In this case, no PIP is required."),(0,i.yg)("p",null,"There are a lot of good solutions out there for RBAC, for any modern web framework from any language, so I will not go into details about this, but I just wanted to briefly mention it. ",(0,i.yg)("strong",{parentName:"p"},"The only tip I do wanna share though, in case you are implementing something custom"),", is that the ",(0,i.yg)("strong",{parentName:"p"},"resource")," in your policies will probably be the ",(0,i.yg)("strong",{parentName:"p"},"regex route path")," and the ",(0,i.yg)("strong",{parentName:"p"},"permission")," will be the ",(0,i.yg)("strong",{parentName:"p"},"HTTP verb")," (",(0,i.yg)("inlineCode",{parentName:"p"},"GET"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"DELETE"),", etc). By doing that, you can easily get the route path from within the middleware and use a regex route matcher library to check if the resource is a match."),(0,i.yg)("h3",{id:"rbacabac"},"RBAC/ABAC"),(0,i.yg)("p",null,"So let's assume that you go with option 3, with an authorization middleware and library per service. How would such implementation look like?"),(0,i.yg)("p",null,"The following implementation approach is neither the best, nor the only one. It is however applicable to the real world and that's what is important for me. ",(0,i.yg)("strong",{parentName:"p"},"What we are basically trying to answer with our implementation is:")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"How will my authorization mechanism load the necessary application data it needs?")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"How will I express my policies, in a non confusing way, and be able to access dynamically loaded data from within those policies?"))),(0,i.yg)("p",null,"By answering the above questions we will also be able to provide a better answer back to our friend ",(0,i.yg)("em",{parentName:"p"},"the monolith")," and its question, ",(0,i.yg)("em",{parentName:"p"},"how will we allow a user to do X on Y resource if their roles allows it, or if it's owned by them?")),(0,i.yg)("p",null,"The example is written in ",(0,i.yg)("inlineCode",{parentName:"p"},"Node.js"),", but I am confident you can do something similar in any web framework of your choice. Also, please do keep in mind that I have omitted a lot of code and kept a flat structure in order to try to reduce any confusion with unecessary implementation details. I understand that it can be frustrating but I will try to explain in detail what everything is supposed to do."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js",metastring:"title=server.js",title:"server.js"},"import express from 'express'; // express is a web framework for Node.js \nimport logger from '/your/logger';\nimport {\n  AccessControl, \n  ROLE, \n  PREDICATE\n} from '/your/access/control/lib';\n\n// `express.js` router handler for listing items and assigned to route `GET /items`. \n// The assignment is done in our `routesObject` further below.\nasync listItemsHandler(res, req, next) {\n  const items = await ItemModel.find(req.query);\n  \n  // ... rest of handler; no authorization checks required \n}\n\n// `express.js` router handler for getting a specific item and assigned to route `GET /items/:id`. \n// The assignment is done in our `routesObject` further below.\nasync getItemHandler(res, req, next) {\n  const {id} = req.params;\n  \n  const item = await ItemModel.findById(id);\n  \n  if (!item) {\n    throw new ItemNotFoundError();\n  }\n  \n  // ... rest of handler; no authorization checks required\n}\n\n/*\n  This is a function that represents an `express.js` middleware. It's basically code that will run BEFORE \n  the `listItemsHandler` and the `getItemHandler` implemented above. The middleware acts as the PEP \n  and  internally uses our access control library in order to decide if it should allow a request or not.\n  \n  Check here for extra info on middlewares: https://expressjs.com/en/guide/using-middleware.html\n*/\nfunction authorizationExpressMiddleware(request, response, next()) {\n  // Get the user object from the JWT token that is attached to the request.\n  // Usually this happens within a middleware higher up in the middleware chain.\n  const user = request.locals?.user? || null;\n  const userRole = request.locals?.user?.role? || ROLE.GUEST;\n\n  // This is just an object with data that we want to pass to our access control library that is related\n  // with this request. Everything in this object will be accessible by specifying the appropriate \n  // object path in the `conditions` key of our policy definitions as we will see later.\n  const context = {\n    user,\n    request\n  };\n\n  const action = request.method; // GET, DELETE, PUT, etc\n  const resource = path.join(request.baseUrl, request.route.path); // e.g. /items/:id\n\n  // Check if the current request is authorized, by also including our `context` object. \n  const isAuthorized = await accessControl\n    .withContext(context)\n    .can(userRole, action, resource);\n    \n  // If the request is authorized, then pass the control to the next middleware in the chain.\n  if (isAuthorized) {\n    return next(); \n  }\n  \n  // Request is UNAUTHORIZED. Set the HTTP response status and stop the rest of the middleware \n  // chain from executing by returning an error. The request will stop here.\n  response.status(401); // Unauthorized\n  next(new AuthorizationError());\n}\n\n/*\n  Initialization function for our access control library. This is an imaginary custom PDP library\n  that internally uses an imaginary custom PIP library. Using the PIP part of the access control \n  library should be optional.\n*/\nfunction initAccessControl(endpointsObject) {\n  // PIP loader function in order to load a specific item and provide to\n  // the access control library the extra information it needs.\n  const pipItemLoader = async (itemId) => {\n    const item = await ItemModel.findById(itemId);\n    \n    if (item) {\n      return item; \n    }\n    \n    return null;\n  }\n\n  // Initialize the access control library with two roles. The library should be able \n  // to support hierarchical roles in order to inherit permissions from a parent role \n  // instead of repeating them, just like below.\n  const roles = [{\n    name: ROLE.USER\n  }, {\n    name: ROLE.ADMIN\n    inherits: [ROLE.USER]\n  }];\n  \n  const accessControl = new AccessControl(roles);\n  \n  // Add our loader to the access control library in order to be able to use it internally when necessary.\n  accessControl.addLoader(PIP_LOADER_TYPE.ITEM, pipItemLoader)\n  \n  // `buildPermissions` is a custom utility function that parses the `accessControl` key object value from \n  // our endpoints object and creates a list of permission objects, formatted the way our access\n  // control library expects them.\n  const permissions = buildPermissions(endpointsObject);\n\n  accessControl.addPermissions(permissions);\n\n  return accessControl;\n}\n\n// The following object contains everything we need to describe all the exposed routes. Within the object,\n// we have also embedded our authorization policies via the `accessControl` key. Within this key, we specify\n// which role can do what and under which conditions.\nconst routesObject = {\n    middlewares: [authorizationExpressMiddleware],\n    endpoints: {\n     '/items': {\n      '/': {\n        GET: {\n          handler: listItemsHandler,\n          accessControl: {\n            permissions: [{\n              role: ROLE.USER,\n              // The 'user' role can only list items which the `user_id` filter matches the user who request them.\n              condition: {predicate: PREDICATE.EQUAL, args: ['$.request.query.user_id', '$.user.id']}\n            }, {\n              role: ROLE.ADMIN,\n              // The admin role can list items with any filters they like.\n              condition: * // Any filter is allowed\n            }]\n          }\n        },\n        '/:id': {\n          GET: {\n            handler: getItemHandler,\n            accessControl: {\n              loader: {fn: PIP_LOADER_TYPE.ITEM, args: ['$.request.params.id']},\n              permissions: [{\n                role: ROLE.USER,\n                // The 'user' role can only get an item that is owned by the user who requested it.\n                condition: {predicate: PREDICATE.EQUAL, args: ['$.resource.userId', '$.user.id']}\n              }]\n            }\n          }\n        }\n      },\n     }\n    }\n  }\n};\n\n// Initialize access control and our app.\nconst accessControl = initAccessControl(routesObject.endpoints);\nconst app = express();\n\n// `buildRoutes` is a custom utility function that parses the routes object and adds all the specified routes \n// to our express.js router by also associated them with the respective handler. The function will also apply\n// the `middlewares` array from the object to all routes which means that each request will need to go\n// through our authorization middleware.\n//\n// Check the express.js router here: https://expressjs.com/en/guide/routing.html\nbuildRoutes(app, routesObject);\n\napp.listen(3000, () => {\n  logger.info(`kitten app listening at http://localhost:3000`)\n})\n\n")),(0,i.yg)("p",null,"I tried to keep the example code as succinct as possible in order for everyone to understand, even if they are not familiar with ",(0,i.yg)("inlineCode",{parentName:"p"},"Node.js"),". The important take from the code above is that you ",(0,i.yg)("em",{parentName:"p"},"could")," use an object to describe your policies, along with your routes, and pass values to those policies by expressing paths from dynamically loaded data that can be used during the evaluation step within our access control library. "),(0,i.yg)("p",null,"You have probably noticed that in the ",(0,i.yg)("inlineCode",{parentName:"p"},"condition")," key some weird stuff are happening in the ",(0,i.yg)("inlineCode",{parentName:"p"},"args")," that are prefixed with ",(0,i.yg)("inlineCode",{parentName:"p"},"$"),". What is happening there is that I am using ",(0,i.yg)("a",{parentName:"p",href:"https://restfulapi.net/json-jsonpath/"},"JSON path syntax")," in order to specify the location of the data (within the ",(0,i.yg)("inlineCode",{parentName:"p"},"context")," object) that will be passed as arguments to the predicate; In this case, ",(0,i.yg)("inlineCode",{parentName:"p"},"PREDICATE.EQUAL"),", which as the name implies, is a predicate for equality check."),(0,i.yg)("p",null,"If you re-read the code, you will see that the ",(0,i.yg)("inlineCode",{parentName:"p"},"authorizationMiddleware")," passes a ",(0,i.yg)("inlineCode",{parentName:"p"},"context")," object to the access control library that includes the ",(0,i.yg)("inlineCode",{parentName:"p"},"request")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"user")," objects. That's how they are available for access with the JSON path syntax. As for the ",(0,i.yg)("inlineCode",{parentName:"p"},"$.resource")," in the ",(0,i.yg)("inlineCode",{parentName:"p"},"args"),", it's just a key name I choose to attach the data returned from the ",(0,i.yg)("inlineCode",{parentName:"p"},"pipItemLoader")," and automatically attached to the ",(0,i.yg)("inlineCode",{parentName:"p"},"context")," (this happens inside our imaginary custom PIP library). That means, that the ",(0,i.yg)("inlineCode",{parentName:"p"},"resource")," represents an ",(0,i.yg)("inlineCode",{parentName:"p"},"item")," object with a field named ",(0,i.yg)("inlineCode",{parentName:"p"},"userId")," which we can now access with JSON path syntax."),(0,i.yg)("p",null,"Like I have already mentioned, the above is one way to do it, and it works well. You could go with something that is more general-purpose and advanced like a policy engine (e.g ",(0,i.yg)("a",{parentName:"p",href:"https://www.openpolicyagent.org/"},"OPA"),") but I assure you that they are definitely not a free meal either, nor without limitations. Once again, it comes down to the details of your own system and what you are trying to achieve."),(0,i.yg)("p",null,(0,i.yg)("em",{parentName:"p"},"(UPDATE 23/05/2022): ",(0,i.yg)("a",{parentName:"em",href:"https://github.com/cerbos/cerbos"},"Cerbos"),' recently came to my attention which follows this "contextual" approach I am describing above. Maybe you can check it out as well!')),(0,i.yg)("h3",{id:"potential-problems"},"Potential problems"),(0,i.yg)("p",null,"I would like to briefly mention a few situations that you might come up against as a heads up and what you can try to do in order to solve them."),(0,i.yg)("h5",{id:"bulk-enforcement"},"Bulk enforcement"),(0,i.yg)("p",null,"This becomes apparent as soon as you have some kind of listing endpoint. How will you check if the user is authorized to access all the items in the result? Checking them one by one is probably the first thing that comes to mind, but that means you will have to load them first, plus, it might be slow if you need to keep loading 1000 items on every request even for users that are not allowed to access that data."),(0,i.yg)("p",null,"In our implementation above this is solved with our routes map and the ",(0,i.yg)("inlineCode",{parentName:"p"},"condition")," key. When you are listing items, you are probably passing some kind of filters to the endpoint via query parameters, which means you can easily use those filters and decide what to do before you even load the data. For roles that are allowed to pass whatever filters they want (e.g. an admin role), you can just omit the ",(0,i.yg)("inlineCode",{parentName:"p"},"condition")," key."),(0,i.yg)("p",null,"The important thing here is that the authorization mechanism is not getting coupled with internal details of how you actually implement your data filtering. It just stays on a very shallow layer of your service which is publicly available to use."),(0,i.yg)("h5",{id:"not-found-requests-in-pip-loaders"},"Not Found requests in PIP loaders"),(0,i.yg)("p",null,"This is something that I am still working on myself. I have tried various approaches but I am not 100% satisfied with any of them."),(0,i.yg)("p",null,"Let's asume that you have your ",(0,i.yg)("inlineCode",{parentName:"p"},"pipItemLoader")," in which you load an item with id X. What should happen if the item does not exist? Should we return an authorization error? Should we return an ",(0,i.yg)("inlineCode",{parentName:"p"},"ItemNotFound")," error? If we do the first one, isn't it misleading for the API caller? Especially if the user actually has access to load items. If we do the second one, before we check if the user is authorized for this action, wouldn't it be bad from a security perspective to provide such info? Maybe we should return a special value from the loader and if it's detected to let the request go through, and HOPEFULLY, our controller will be doing checks if the item exists or not."),(0,i.yg)("p",null,"You can try any of the above and something might fit your needs, or you can be creative and let me know if you find something interesting as well!"),(0,i.yg)("h5",{id:"duplicate-database-round-trips"},"Duplicate database round trips"),(0,i.yg)("p",null,"As you might have noticed on our implementation above for the ",(0,i.yg)("inlineCode",{parentName:"p"},"GET")," endpoint, is that we are loading the same item twice; once in the ",(0,i.yg)("inlineCode",{parentName:"p"},"pipItemLoader")," and once in ",(0,i.yg)("inlineCode",{parentName:"p"},"getItemHandler"),". Why hit the database twice when you can just avoid it?"),(0,i.yg)("p",null,"One solution is to cache the data in order for the second call to return the cached data. But why hit the cache when you can avoid that as well? How? Just use a data loader and persist the data in RAM (and cache them as a side effect) for as long as the request lives and clear them upon finish with a middleware. For example, for ",(0,i.yg)("inlineCode",{parentName:"p"},"Node.js")," you could use the ",(0,i.yg)("a",{parentName:"p",href:"https://www.npmjs.com/package/dataloader"},"dataloader")," package. I am pretty sure there are similar solutions in whatever you might be using."),(0,i.yg)("p",null,"Of course, none of this is necessary and might be too much. Once again, it depends on how everything is implemented on your side and more importantly, your incoming traffic load."),(0,i.yg)("h5",{id:"restricting-resource-fields"},"Restricting resource fields"),(0,i.yg)("p",null,"Depending on user access level, return resources with specific fields removed. Some authorization libraries that I have seen provide a way to do this by exposing a function/method, but in my opinion this does not really belong there. I feel like this is a job for an authorization middleware, or at least something other than the library itself which should be kept as tight as possible."),(0,i.yg)("p",null,"If you are using the routes map approach above, then you can easily extend it to support this by adding an extra key that describes the fields that are allowed and let the middleware remove the rest."),(0,i.yg)("h2",{id:"conclusion"},"Conclusion"),(0,i.yg)("p",null,"As you saw, implementing authorization is hard, but it's also a very interesting challenge."),(0,i.yg)("p",null,"Although there is a popular belief that in a monolith is easier to implement authorization, in my opinion both the monolith and a microservices architecture have a lot in common when it comes to the authorization mechanism when that same mechanism has access to the application data it needs. The main difference is, as long as that mechanism no longer has a straight forward way to get that data, things start to get more complicated. Due to the independent nature of microservices, this can be easily observed, but the same complexity can be also observed within the same organization if multiple monoliths need to have a common authorization system."),(0,i.yg)("p",null,"I am definitely not done with looking for better solutions than the ones I have already suggested and I am looking forward to hearing what others are doing."),(0,i.yg)("p",null,"The good thing is, that more and more people are starting to take this more seriously and spend more time on it. Hopefully, at some point we will solve it more elegantly and have a more unified approach. Until then, good luck!"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"PS:")," I know you are going to ask me, so I am telling you right now that I made all the diagrams with ",(0,i.yg)("a",{parentName:"p",href:"https://drawio-app.com/"},"draw.io"),"."))}c.isMDXComponent=!0},2755:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/authorization_architecture_api_gateway_data_service-0b3ce09676ba0e94debaec46c09cc681.jpg"},697:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/authorization_architecture_authorization_and_data_service-69c2c84ecf53d7527e708c695c554f55.jpg"},8930:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/authorization_architecture_authorization_service-131cac666b0b1feac9d7f636e04929bf.jpg"},2540:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/authorization_architecture_overview-a7f2e4f08870034de08c831e81aae323.jpg"},360:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/authorization_architecture_service_library-7003f6c7223ce5634575390d72c385e6.jpg"}}]);